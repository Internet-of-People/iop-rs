use super::*;

/// Private keys for a given DID kind in the Morpheus subtree in a vault.
///
/// @see MorpheusPrivate.kind
#[wasm_bindgen(js_name = MorpheusPrivateKind)]
pub struct JsMorpheusPrivateKind {
    inner: MorpheusPrivateKind,
}

#[wasm_bindgen(js_class = MorpheusPrivateKind)]
impl JsMorpheusPrivateKind {
    /// Accessor for the kind of identifiers generated by this subtree.
    #[wasm_bindgen(getter)]
    pub fn kind(&self) -> String {
        format!("{:?}", self.inner.path())
    }

    /// Accessor for the BIP32 path of the subtree with the given DID kinds.
    #[wasm_bindgen(getter = path)]
    pub fn bip32_path(&self) -> String {
        self.inner.node().path().to_string()
    }

    /// Retrieves how many DIDs have already be generated of this kind.
    #[wasm_bindgen(getter)]
    pub fn count(&self) -> Result<u32, JsValue> {
        self.inner.len().map_err_to_js()
    }

    /// Accessor for the public keys that belong to this subtree in a vault.
    ///
    /// @see MorpheusPlugin.pub, MorpheusPublic.kind
    #[wasm_bindgen(getter = pub)]
    pub fn neuter(&self) -> JsMorpheusPublicKind {
        let inner = self.inner.neuter();
        JsMorpheusPublicKind::from(inner)
    }

    /// Generates the {@link MorpheusPrivateKey} with the given index.
    ///
    /// The result has methods to be converted into a {@link Did} or a
    /// {@link KeyId} or for authenticating actions signed by the
    /// {@link PrivateKey} that belongs to that key.
    pub fn key(&mut self, idx: i32) -> Result<JsMorpheusPrivateKey, JsValue> {
        let inner = self.inner.key_mut(idx).map_err_to_js()?;
        Ok(JsMorpheusPrivateKey::from(inner))
    }

    /// Generates the {@link Did} with the given index.
    pub fn did(&mut self, idx: i32) -> Result<JsDid, JsValue> {
        let sk = self.inner.key_mut(idx).map_err_to_js()?;
        let inner = Did::from(sk.neuter().public_key().key_id());
        Ok(JsDid::from(inner))
    }

    /// Finds the {@link MorpheusPrivateKey} that belongs to the given multicipher {@link PublicKey}. You can check the DID kind or
    /// index of the key or get the actual {@link PrivateKey} from the returned object.
    ///
    /// An error will be thrown if the public key has never been used yet in this vault or is not this kind of DID.
    #[wasm_bindgen(js_name = keyByPublicKey)]
    pub fn key_by_pk(&self, id: &JsMPublicKey) -> Result<JsMorpheusPrivateKey, JsValue> {
        let inner = self.inner.key_by_pk(id.inner()).map_err_to_js()?;
        Ok(JsMorpheusPrivateKey::from(inner))
    }
}

impl From<MorpheusPrivateKind> for JsMorpheusPrivateKind {
    fn from(inner: MorpheusPrivateKind) -> Self {
        Self { inner }
    }
}

impl Wraps<MorpheusPrivateKind> for JsMorpheusPrivateKind {
    fn inner(&self) -> &MorpheusPrivateKind {
        &self.inner
    }
}

impl WrapsMut<MorpheusPrivateKind> for JsMorpheusPrivateKind {
    fn inner_mut(&mut self) -> &mut MorpheusPrivateKind {
        &mut self.inner
    }
}
